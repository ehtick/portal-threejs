/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.13 /Users/thomasmatlock/Documents/Github/portal/public/models/meshes/HappyIdle/HappyIdle.gltf --output /Users/thomasmatlock/Documents/Github/portal/models/HappyIdle.tsx -r /models/meshes/HappyIdle -t --resolution 512 --shadows --meta --keepmeshes --keepmaterials 
*/

import * as THREE from 'three'
import React, { useRef } from 'react'
import { useGLTF, useAnimations } from '@react-three/drei'
import { GLTF } from 'three-stdlib';
import { useFrame, useThree } from "@react-three/fiber";
import { useScroll, Detailed } from '@react-three/drei';
import { easing, geometry } from 'maath';
import UserContextProvider from '@/context/userContext';
import InputContextProvider from '@/context/inputContext';
import { useContext, useState } from 'react';
import pointerEventHandlers from './shared/pointerEventHandlers';

        

type GLTFResult = GLTF & {
  nodes: {
    Ch45001: THREE.SkinnedMesh
    mixamorig1Hips: THREE.Bone
  }
  materials: {
    ['Ch45_Body.001']: THREE.MeshStandardMaterial
  }
}

type ActionName = 'Armature.001|mixamo.com|Layer0' | 'Armature|mixamo.com|Layer0'
type GLTFActions = Record<ActionName, THREE.AnimationAction>

// type ContextType = Record<string, React.ForwardRefExoticComponent<JSX.IntrinsicElements['skinnedMesh'] | JSX.IntrinsicElements['bone']>>

interface GLTFAction extends THREE.AnimationClip {
    name: ActionName;
}
export function Model(props: {scrollable?: boolean, distances?: number[]} & JSX.IntrinsicElements['group']) {
  const group = useRef<THREE.Group>()
  
    const { frameloop, dev, mobile } = useContext(UserContextProvider);
    const { timestamp, scrollSpeed, scrollDirection, scrolling, activeObject, clipDuration, setClipDuration } = useContext(InputContextProvider);
    const { scrollable } = props.scrollable ? props : { scrollable: false };
    const scroll = useScroll();
    const { clock, controls, camera, scene } = useThree();
    const { nodes, materials, animations } = useGLTF('/../../models/meshes/HappyIdle/HappyIdle.gltf') as GLTFResult
  const { actions } = useAnimations(animations, group)
  useFrame((state) => {
        const clock = state.clock;
        const controls = state.controls;
        const camera = state.camera;
        const scene = state.scene;
        const elapsedTime = clock.getElapsedTime();
        if (actions[Layer0'].getClip().duration > clipDuration)
                setClipDuration(actions[Layer0'].getClip().duration);
        
            if(scrollable){
                actions['Armature.001].time = scroll.offset * clipDuration
                if(scrolling.current){
                    actions['Armature.001].play()
                }else{
                    actions['Armature.001].play().paused = true
                }
            }
            if(!scrollable){
                actions['Armature.001].play();
                actions['Armature.001].time = elapsedTime % clipDuration;
                actions['Armature.001].setLoop(THREE.LoopRepeat, Infinity);
            }
        

            if(scrollable){
                actions[mixamo.com].time = scroll.offset * clipDuration
                if(scrolling.current){
                    actions[mixamo.com].play()
                }else{
                    actions[mixamo.com].play().paused = true
                }
            }
            if(!scrollable){
                actions[mixamo.com].play();
                actions[mixamo.com].time = elapsedTime % clipDuration;
                actions[mixamo.com].setLoop(THREE.LoopRepeat, Infinity);
            }
        

            if(scrollable){
                actions[Layer0'].time = scroll.offset * clipDuration
                if(scrolling.current){
                    actions[Layer0'].play()
                }else{
                    actions[Layer0'].play().paused = true
                }
            }
            if(!scrollable){
                actions[Layer0'].play();
                actions[Layer0'].time = elapsedTime % clipDuration;
                actions[Layer0'].setLoop(THREE.LoopRepeat, Infinity);
            }
        

            if(scrollable){
                actions['Armature].time = scroll.offset * clipDuration
                if(scrolling.current){
                    actions['Armature].play()
                }else{
                    actions['Armature].play().paused = true
                }
            }
            if(!scrollable){
                actions['Armature].play();
                actions['Armature].time = elapsedTime % clipDuration;
                actions['Armature].setLoop(THREE.LoopRepeat, Infinity);
            }
        

            if(scrollable){
                actions[mixamo.com].time = scroll.offset * clipDuration
                if(scrolling.current){
                    actions[mixamo.com].play()
                }else{
                    actions[mixamo.com].play().paused = true
                }
            }
            if(!scrollable){
                actions[mixamo.com].play();
                actions[mixamo.com].time = elapsedTime % clipDuration;
                actions[mixamo.com].setLoop(THREE.LoopRepeat, Infinity);
            }
        

            if(scrollable){
                actions[Layer0'].time = scroll.offset * clipDuration
                if(scrolling.current){
                    actions[Layer0'].play()
                }else{
                    actions[Layer0'].play().paused = true
                }
            }
            if(!scrollable){
                actions[Layer0'].play();
                actions[Layer0'].time = elapsedTime % clipDuration;
                actions[Layer0'].setLoop(THREE.LoopRepeat, Infinity);
            }
        
    }); return (
    <group ref={group} {...props} dispose={null}>
            

            <Detailed distances={props.distances || [0, 4, 8, 12]} >
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.13 /Users/thomasmatlock/Documents/Github/portal/public/models/meshes/HappyIdle/HappyIdle.gltf --output /Users/thomasmatlock/Documents/Github/portal/models/HappyIdle.tsx -r /models/meshes/HappyIdle -t --resolution 512 --shadows --meta --keepmeshes --keepmaterials 
*/

import * as THREE from 'three'
import React, { useRef } from 'react'
import { useGLTF, useAnimations } from '@react-three/drei'
import { GLTF } from 'three-stdlib';
import { useFrame, useThree } from "@react-three/fiber";
import { useScroll, Detailed } from '@react-three/drei';
import { easing, geometry } from 'maath';
import UserContextProvider from '@/context/userContext';
import InputContextProvider from '@/context/inputContext';
import { useContext, useState } from 'react';
import pointerEventHandlers from './shared/pointerEventHandlers';

        

type GLTFResult = GLTF & {
  nodes: {
    Ch45001: THREE.SkinnedMesh
    mixamorig1Hips: THREE.Bone
  }
  materials: {
    ['Ch45_Body.001']: THREE.MeshStandardMaterial
  }
}

type ActionName = 'Armature.001|mixamo.com|Layer0' | 'Armature|mixamo.com|Layer0'
type GLTFActions = Record<ActionName, THREE.AnimationAction>

// type ContextType = Record<string, React.ForwardRefExoticComponent<JSX.IntrinsicElements['skinnedMesh'] | JSX.IntrinsicElements['bone']>>

interface GLTFAction extends THREE.AnimationClip {
    name: ActionName;
}
export function Model(props: {scrollable?: boolean, distances?: number[]} & JSX.IntrinsicElements['group']) {
  const group = useRef<THREE.Group>()
  
    const { frameloop, dev, mobile } = useContext(UserContextProvider);
    const { timestamp, scrollSpeed, scrollDirection, scrolling, activeObject, clipDuration, setClipDuration } = useContext(InputContextProvider);
    const { scrollable } = props.scrollable ? props : { scrollable: false };
    const scroll = useScroll();
    const { clock, controls, camera, scene } = useThree();
    const { nodes, materials, animations } = useGLTF('/../../models/meshes/HappyIdle/HappyIdle.gltf') as GLTFResult
  const { actions } = useAnimations(animations, group)
  useFrame((state) => {
        const clock = state.clock;
        const controls = state.controls;
        const camera = state.camera;
        const scene = state.scene;
        const elapsedTime = clock.getElapsedTime();
        if (actions[Layer0'].getClip().duration > clipDuration)
                setClipDuration(actions[Layer0'].getClip().duration);
        
            if(scrollable){
                actions['Armature.001].time = scroll.offset * clipDuration
                if(scrolling.current){
                    actions['Armature.001].play()
                }else{
                    actions['Armature.001].play().paused = true
                }
            }
            if(!scrollable){
                actions['Armature.001].play();
                actions['Armature.001].time = elapsedTime % clipDuration;
                actions['Armature.001].setLoop(THREE.LoopRepeat, Infinity);
            }
        

            if(scrollable){
                actions[mixamo.com].time = scroll.offset * clipDuration
                if(scrolling.current){
                    actions[mixamo.com].play()
                }else{
                    actions[mixamo.com].play().paused = true
                }
            }
            if(!scrollable){
                actions[mixamo.com].play();
                actions[mixamo.com].time = elapsedTime % clipDuration;
                actions[mixamo.com].setLoop(THREE.LoopRepeat, Infinity);
            }
        

            if(scrollable){
                actions[Layer0'].time = scroll.offset * clipDuration
                if(scrolling.current){
                    actions[Layer0'].play()
                }else{
                    actions[Layer0'].play().paused = true
                }
            }
            if(!scrollable){
                actions[Layer0'].play();
                actions[Layer0'].time = elapsedTime % clipDuration;
                actions[Layer0'].setLoop(THREE.LoopRepeat, Infinity);
            }
        

            if(scrollable){
                actions['Armature].time = scroll.offset * clipDuration
                if(scrolling.current){
                    actions['Armature].play()
                }else{
                    actions['Armature].play().paused = true
                }
            }
            if(!scrollable){
                actions['Armature].play();
                actions['Armature].time = elapsedTime % clipDuration;
                actions['Armature].setLoop(THREE.LoopRepeat, Infinity);
            }
        

            if(scrollable){
                actions[mixamo.com].time = scroll.offset * clipDuration
                if(scrolling.current){
                    actions[mixamo.com].play()
                }else{
                    actions[mixamo.com].play().paused = true
                }
            }
            if(!scrollable){
                actions[mixamo.com].play();
                actions[mixamo.com].time = elapsedTime % clipDuration;
                actions[mixamo.com].setLoop(THREE.LoopRepeat, Infinity);
            }
        

            if(scrollable){
                actions[Layer0'].time = scroll.offset * clipDuration
                if(scrolling.current){
                    actions[Layer0'].play()
                }else{
                    actions[Layer0'].play().paused = true
                }
            }
            if(!scrollable){
                actions[Layer0'].play();
                actions[Layer0'].time = elapsedTime % clipDuration;
                actions[Layer0'].setLoop(THREE.LoopRepeat, Infinity);
            }
        
    }); return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <group name="Armature001" rotation={[Math.PI / 2, 0, 0]} scale={0.01} userData={{ name: 'Armature.001' }}>
          <primitive object={nodes.mixamorig1Hips} />
          <skinnedMesh name="Ch45001" geometry={nodes.Ch45001.geometry} material={materials['Ch45_Body.001']} skeleton={nodes.Ch45001.skeleton} userData={{ name: 'Ch45.001' }} />
        </group>
      </group>
    
            </Detailed>
</group>
  )
}

useGLTF.preload('/../../models/meshes/HappyIdle/HappyIdle.gltf')
